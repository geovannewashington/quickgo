# Type Conversion in Go

In Go, type conversion uses the syntax:

```go
// var <varName> <targetType> = <targetType>(value)
```

### Example:

```go
var integerValue int = 10
var floatValue float64 = float64(integerValue)
```

# Additional Notes

- `byte` is an alias to `uint8`.

```go
n := byte('\n') // '\n' is newline, ASCII decimal value 10
// Equivalent to n := uint8('\n')
```

- Assigning a value outside the valid range of a type is a **compile-time error** (no silent overflow
  like in C)

```go
var num uint8 = 256 // compile-time error
```

- `%T` in `fmt.Printf` is useful for printing a variable's type:

```go
fmt.Printf("Integer: %d, Type: %T\n", integerValue, integerValue)
fmt.Printf("Integer: %d, Type: %T\n", floatValue, floatValue)
```

# Arrays in Go

General syntax:

```go
var arrayName [length]dataType
```

### Examples:

```go
var a4 [4]int // An array of 4 ints, all initialized to zero by default

a5 := [...]int{3, 1, 5, 10, 100} // Compiler infers size (5 elements)

var myArray = [3]int{10, 20, 30}
anotherArray := [...]int{10, 20}
```

### Key Characteristics

- Arrays in Go are fixed-length and must have their size determined at compile time.
- They are stored in contiguous memory.
- Slices are more flexible; they can grow and shrink.
- Arrays have value semantics:

```go
a4Copy := a4 // Creates a full copy of `a4` - two separate arrays in memory.
```
