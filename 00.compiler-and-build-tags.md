## About the compiler.

Although GCC is capable of compiling Go source files, Go comes with its own compiler as part of the
official installation process (which on Linux is basically extracting a compacted directory into /usr/local/go/)

Some examples:

```bash
# Procudes a binary but doesn't install it.
# Compiles Go source files in the current
go build main.go # Outputs `./main`

# We can also specify an output name with -o flag
go build main.go -o main

# Compiles and runs the code immediately
go run main.go
# Temporarily builds a binary in /tmp, then executes it.
# Deletes the binary after execution.

# Builds and installs the binary to your `@GOBIN` or `@GOPATH/bin`
# In my case @GOBIN is not defined, and @GOPATH/bin is $HOME/go/bin
# This is used to make CLI available globally.
go install github.com/user/tool@latest
```

## Build Tags

Build tags are special comments that let you build code selectively, e.g.: different OS, architectures, etc...
A build tag is placed before the package clause near or at the top of the file.

```go
//go:build linux
// +build linux

// This means: only compile this file when building for Linux.
```

Note that `// +build` here is just for backward compability purposes only.

### Custom Tags:

You can define your own tags:

```go
//go:build debug
// +build debug
```

Then compile using: `go build -tags=debug`

Let's see first example in ~/examples/00-debug-example

```plaintext
examples/
├─ 00-debug-example/
│  ├─ debug.go
│  ├─ main.go
│  ├─ release.go
```

Notice that you do: `go build -tags=debug .`, you don't specify any file names, go already resolves it for you.
This means: build all files within the current directory, filtering them properly with build tags.
Notice that if you try `go run -tags=debug .`, go will complain if you don't have a `go mod` file.
